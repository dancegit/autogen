Page: modal.com_files/modal.com/docs/guide/sandbox.html
----------------------------------------
   [1]Modal logo
   [2]Guide [3]Examples [4]Reference [5]Playground
   [6]Log In [7]Sign Up
   (BUTTON)
   [8]Introduction[9]Custom container images [10]Custom
   containers[11]Private registries[12]GPUs and other resources [13]GPU
   acceleration[14]Using CUDA on Modal[15]Reserving CPU and
   memory[16]Scaling out [17]Scaling out[18]Dicts and queues[19]Job
   processing[20]Concurrent inputs on a single container (beta)[21]Dynamic
   batching (beta)[22]Scheduling and cron jobs[23]Deployment [24]Apps,
   Stubs, and entrypoints[25]Managing deployments[26]Invoke deployed
   functions[27]Continuous deployment[28]Secrets and environment variables
   [29]Secrets[30]Environment variables[31]Web endpoints [32]Web
   endpoints[33]Streaming endpoints[34]Web endpoint URLs[35]Request
   timeouts[36]Networking [37]Tunnels (beta)[38]Proxies (beta)[39]Data
   sharing and storage [40]Passing local data[41]Volumes[42]Mounting local
   files and directories[43]Storing model weights[44]Dataset
   ingestion[45]Cloud bucket mounts[46]Network file systems
   (superseded)[47]Sandboxes [48]Sandboxes[49]Running
   commands[50]Networking and security[51]File access[52]Performance
   [53]Cold start performance[54]Memory Snapshot (beta)[55]Geographic
   latency[56]Reliability and robustness [57]Failures and
   retries[58]Preemption[59]Timeouts[60]Troubleshooting[61]Security and
   privacy[62]Integrations [63]Connecting Modal to your Vercel
   account[64]Connecting Modal to your Datadog account[65]Connecting Modal
   to your OpenTelemetry provider[66]Okta SSO[67]Slack notifications
   (beta)[68]Other topics [69]File and project structure[70]Developing and
   debugging[71]Modal user account
   setup[72]Workspaces[73]Environments[74]Jupyter
   notebooks[75]Asynchronous API usage[76]Global variables[77]Region
   selection[78]Container lifecycle hooks[79]Parameterized functions[80]S3
   Gateway endpoints
     __________________________________________________________________

Sandboxes

   In addition to the Function interface, Modal has a direct interface for
   defining containers at runtime and securely running arbitrary code
   inside them.

   This can be useful if, for example, you want to:
     * Execute code generated by a language model.
     * Create isolated environments for running untrusted code.
     * Check out a git repository and run a command against it, like a
       test suite, or npm lint.
     * Run containers with arbitrary dependencies and setup scripts.

   Each individual job is called a Sandbox and can be created using the
   [81]Sandbox.create constructor:
import modal

app = modal.App.lookup("my-app", create_if_missing=True)

sb = modal.Sandbox.create(app=app)

p = sb.exec("python", "-c", "print('hello')")
print(p.stdout.read())

p = sb.exec("bash", "-c", "for i in {1..10}; do date +%T; sleep 0.5; done")
for line in p.stdout:
    # Avoid double newlines by using end="".
    print(line, end="")

sb.terminate()

   (BUTTON) Copy

   Sandboxes require an [82]App to be passed when spawned from outside of
   a Modal container. You may pass in a regular App object or look one up
   by name with [83]App.lookup. The create_if_missing flag on App.lookup
   will create an App with the given name if it doesn't exist.

Running a Sandbox with an entrypoint

   In most cases, Sandboxes are treated as a generic container that can
   run arbitrary commands. However, in some cases, you may want to run a
   single command or script as the entrypoint of the Sandbox. You can do
   this by passing string arguments to the Sandbox constructor:
sb = modal.Sandbox.create("python", "-m", "http.server", "8080", app=my_app, tim
eout=10)
for line in sb.stdout:
    print(line, end="")

   (BUTTON) Copy

   This functionality is most useful for running long-lived services that
   you want to keep running in the background. See our [84]Jupyter
   notebook example for a more concrete example of this.

Referencing Sandboxes from other code

   If you have a running Sandbox, you can retrieve it using the
   [85]Sandbox.from_id method.
sb = modal.Sandbox.create(app=my_app)
sb_id = sb.object_id

# ... later in the program ...

sb2 = modal.Sandbox.from_id(sb_id)

p = sb2.exec("echo", "hello")
print(p.stdout.read())
sb2.terminate()

   (BUTTON) Copy

   A common use case for this is keeping a pool of Sandboxes available for
   executing tasks as they come in. You can keep a list of object_ids of
   Sandboxes that are "open" and reuse them, closing over the object_id in
   whatever function is using them.

Parameters

   Sandboxes support nearly all configuration options found in regular
   modal.Functions. Refer to [86]Sandbox.create for further documentation
   on Sandbox parameterization.

   For example, Images and Mounts can be used just as with functions:
sb = modal.Sandbox.create(
    image=modal.Image.debian_slim().pip_install("pandas"),
    mounts=[modal.Mount.from_local_dir("./my_repo", remote_path="/repo")],
    workdir="/repo",
    app=my_app,
)

   (BUTTON) Copy

Using custom images

   Sandboxes support custom images just as Functions do. However, while
   you'll typically invoke a Modal Function with the modal run cli, you
   typically spawn a Sandbox with a simple python call. As such, you need
   to manually enable output streaming to see your image build logs:
image = modal.Image.debian_slim().pip_install("pandas", "numpy")

with modal.enable_output():
    sb = modal.Sandbox.create(image=image, app=my_app)

   (BUTTON) Copy

Dynamically defined environments

   Note that any valid Image or Mount can be used with a Sandbox, even if
   those images or mounts have not previously been defined. This also
   means that Images and Mounts can be built from requirements at runtime.
   For example, you could use a language model to write some code and
   define your image, and then spawn a Sandbox with it. Check out
   [87]devlooper for a concrete example of this.

Environment variables

   You can set environment variables using inline secrets:
secret = modal.Secret.from_dict({"MY_SECRET": "hello"})

sb = modal.Sandbox.create(
    secrets=[secret],
    app=my_app,
)
p = sb.exec("bash", "-c", "echo $MY_SECRET")
print(p.stdout.read())

   (BUTTON) Copy

Tagging

   Sandboxes can be tagged with arbitrary key-value pairs. These tags can
   be used to filter results in [88]Sandbox.list.
sandbox_v1_1 = modal.Sandbox.create("sleep", "10", app=my_app)
sandbox_v1_2 = modal.Sandbox.create("sleep", "20", app=my_app)

sandbox_v1_1.set_tags({"major_version": "1", "minor_version": "1"})
sandbox_v1_2.set_tags({"major_version": "1", "minor_version": "2"})

for sandbox in modal.Sandbox.list(app_id=my_app.app_id):  # All sandboxes.
    print(sandbox.object_id)

for sandbox in modal.Sandbox.list(
    app_id=my_app.app_id,
    tags={"major_version": "1"},
):  # Also all sandboxes.
    print(sandbox.object_id)

for sandbox in modal.Sandbox.list(
    app_id=app.app_id,
    tags={"major_version": "1", "minor_version": "2"},
):  # Just the latest sandbox.
    print(sandbox.object_id)

   (BUTTON) Copy
   [89]Sandboxes [90]Running a Sandbox with an entrypoint [91]Referencing
   Sandboxes from other code [92]Parameters [93]Using custom images
   [94]Dynamically defined environments [95]Environment variables
   [96]Tagging
   See it in action
   [97]Building a coding agent with Sandboxes
   [98]Building a code interpreter
   [99]Running a Jupyter notebook
   [100]Safe code execution
   Modal logo Â© 2024
   [101]About [102]Status [103]Changelog [104]Documentation [105]Slack
   Community [106]Pricing [107]Examples

